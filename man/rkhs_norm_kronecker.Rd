% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/norm_kronecker.R
\name{rkhs_norm_kronecker}
\alias{rkhs_norm_kronecker}
\alias{rkhs_norm_kron}
\alias{Kronecker_norm_mat}
\alias{Kronecker_norm_cross}
\title{Efficient RKHS Norm Computation Using Kronecker Structure}
\usage{
rkhs_norm_kron(
  X,
  Y = NULL,
  G_list,
  L_inv = NULL,
  constant = TRUE,
  Index = NULL,
  Ginv = NULL,
  validate = FALSE
)

Kronecker_norm_mat(
  X,
  G,
  alpha,
  constant = TRUE,
  Index = NULL,
  G_list = NULL,
  os_type = "Apple",
  cores = NULL,
  sample_id = 1,
  validate = FALSE
)

Kronecker_norm_cross(
  Xtrain,
  Xnew,
  G,
  alpha,
  constant = TRUE,
  Index = NULL,
  G_list = NULL,
  os_type = "Apple",
  cores = NULL,
  sample_id = 1,
  validate = FALSE
)
}
\arguments{
\item{X, Y}{Input data (vector/matrix/list)}

\item{G_list}{Precomputed eigendecomposition from internal \code{\link{Kronecker_inv_helper}}}

\item{L_inv}{Inverse eigenvalues from internal \code{\link{Lambda_inv}}}

\item{constant}{Logical indicating whether to include constant kernel term in g}

\item{Index}{Matrix of indices for tensor vectorization}

\item{validate}{Logical indicating whether to carry out input validation}

\item{G}{List of kernel matrices from \code{\link{gmat}}}

\item{alpha}{Vector of scale parameters}

\item{os_type}{Parallelization backend ("Windows" or "Apple")}

\item{cores}{Number of cores used for parallel computation}

\item{sample_id}{Mode representing samples, either 1st or last mode}

\item{Xtrain}{Training data}

\item{Xnew}{New data}
}
\value{
\describe{
  \item{\code{rkhs_norm_kron}}{Single norm value between X and Y}
  \item{\code{Kronecker_norm_mat}}{Matrix of pairwise norms between training samples}
  \item{\code{Kronecker_norm_cross}}{Matrix of norms between test and training samples}
}
}
\description{
Compute RKHS norms and related matrices using Kronecker product structure.
}
\details{
These internal functions provide efficient computation of RKHS norms by:
\itemize{
  \item Leveraging Kronecker product structure
  \item Supporting parallel computation
  \item Handling both constant and non-constant kernel terms
}
}
\examples{
# Using internal fire package functions
G <- list(matrix(runif(9),3,3), matrix(runif(4),2,2))
decomp <- fire:::Kronecker_inv_helper(G, alpha = c(0.5, 0.5))
L_inv <- fire:::Lambda_inv(list(decomp$L1, decomp$L2))

# Compute norm between two matrices
X <- matrix(rnorm(6), nrow=3)
rkhs_norm_kron(X, G_list = decomp, L_inv = L_inv)

# Compute pairwise norm matrix
X_list <- list(X, matrix(rnorm(6), nrow=3))
Kronecker_norm_mat(X_list, G, alpha = c(0.5, 0.5))

# Compute cross norms
X_new <- list(matrix(rnorm(6), nrow=3))
Kronecker_norm_cross(X_list, X_new, G, alpha = c(0.5, 0.5))

}
\keyword{internal}
